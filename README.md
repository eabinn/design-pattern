# design-pattern

### 일단 서두

- WeatherData 객체를 사용하여 현재 조건, 기상 통계, 기상 예측, 이렇게 세 항목을 디스플레이 장비에서 갱신해 가면서 보여주는 애플리케이션을 만들어야 한다.

<br>

### 첫 번째 시도, WeatherData 객체 내에 measurementsChanged() 메서드에서 getter함수들로 측정값들을 가져와서 각 화면을 업데이트 해주자.

- 이 방법의 문제점은?
  - 이 메서드 안데 구체적인 구현이 돼 있기 때문에 화면을 추가하려면 이 메서드를 계속 수정해야 한다.
  - 디스플레이를 할 함수들을 공통 인터페이스로 뺼 수 있을 것 같다.

<br>

### 옵저버 패턴은 ...

- 출판사 + 구독자 = 옵저버 패턴
- 주제 객체(subject)에서는 일부 데이터를 관리한다.
- 주제의 데이터가 달라지면 옵저버에게 그 소식이 전해진다.
- 옵저버 객체는 주제 객체를 구독하고 있으며(주제 객체에 등록돼 있으며) 주제의 데이터가 바뀌면 갱신 내용을 전달 받는다.

<br>

### 옵저버 패턴의 정의

- 옵저버 패턴에서는 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의한다.
- 구현하는 방식은 대부분 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인을 바탕으로 한다.

<br>

### 느슨한 결합의 위력

- 두 객체가 느슨하게 결합돼 있다는 것은, 그 둘이 상호작용을 하지만 서로에 대해 잘 모른다는 것을 의미한다.
- 주제가 옵저버에 대해 아는 것은 옵저버가 Observer 인터페이스를 구현했다는 것 정도. 옵저버의 구상 클래스가 무엇인지는 모른다. 옵저버가 무엇을 하는지도 모른다.
- 주제는 Observer 인터페이스를 구현하는 객체의 목록에만 의존하기 때문에 언제든지 새로운 옵저버를 추가 가능하다.
- 주제와 옵저번느 서로 독립적으로 재사용할 수 있다.
- 주제나 옵저버가 바뀌더라도 서로에게 영향을 미치지 않는다. -> 주제 혹은 옵저버 인터페이스만 구현한다는 조건만 만족되면 된다.
  <br>

### 디자인 원칙: 서로 상호작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다. -

- 구상클래스에 의존하는 것이 아닌 인터페이스에 의존하게 한다.
- 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있다. 객체 사이의 의존성을 최소화할 수 있다.

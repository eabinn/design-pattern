# Factory Pattern

## 목적
팩토리 패턴을 이용하여 불필요한 의존성을 없애보자.

---

### "new"는 "구상 객체"를 말한다.
- new를 사용하는 것은 특정 구현(구상클래스의 인스턴스)을 사용하는 것이다.
- 일련의 구상 클래스를 만들떄 다음과 같이 코드를 짜는 경우가 있는데, 이 코드를 보면 만들어지는 인스턴스의 형식(타입)이 실행시에 주어진 조건에 따라 결정된다. 이런 코드가 있다는 것은 뭔가 변경하거나 확장해야 할 때 코드를 다시 확인하고 추가 또는 제거해야 한다는 것을 뜻한다. 이런 코드가 있드면 관리 및 갱신하기가 어려워지고 오류가 생길 가능성도 높아지게 된다.
```
let duck: Duck
duck = picnic ? new MallardDuck() : hunting ? new DecoyDuck() : RubberDuck()
```

### "변화"하는 것 때문에 new를 사용하는데에 있어 조심해야 한다.
- 인터페이스를 바탕으로 코드를 만들면 시스템에서 일어나는 변화를 이겨낼 수 있다. 다형성 덕분에 어떤 클래스든 특정 인터페이스를 특정 인터페이스만 구현하면 사용할 수 있기 때문이다.
- 바뀔 수 있는 부분을 찾아내서 바뀌지 않는 부분하고 분리시키자.

### 피자가게의 발전을 보면서 팩토리 패턴을 알아보자.
1. 가장 초기 개발 단계에서 피자 가게는 피자 종류만 받고 바로 피자(구상 클래스의 인스턴스)를 만든다.
```
class PizzaStore {
  orderPizza(type: string): Pizza {
    const pizza: Pizza = type === 'cheese' ? new CheesePizza() : type === 'greek' ? new GreekPizza() : new PepperoniPizza()
    ...
    return pizza
  }
}
```
- 피자 종류를 추가하거나 삭제하려면 피자 인스턴스를 생성하는 부분을 수정해줘야 한다. 이 부분이 orderPizza() 메서드에서 가장 문제가 되는 부분이다. 이 객체 생성 부분을 캡슐화하자 (다른 객체에 생성 부분을 위임하자). 

2. 이제 객체 생성 부분(피자 인스턴스 생성하는 부분)을 캡슐화하자.
```
class SimplePizzaFactory {
  orderPizza(type: string): Pizza {
    const pizza: Pizza = type === 'cheese' ? new CheesePizza() : type === 'greek' ? new GreekPizza() : new PepperoniPizza()
    return pizza
  }
}
```
- 이 객체에는 팩토리(Factory)라는 이름을 붙이자.
- 이제 orderPizza 함수는 SimplePizzaFactory의 클라이언트가 된다. orderPizza 함수는 SimplePizzaFactory를 호출한다.
`1. 가장 초기 개발 단계에서 피자 가게는 피자 종류만 받고 바로 피자(구상 클래스의 인스턴스)를 만든다.
```
class PizzaStore {
  factory: SimplePizzaFactory
  
  constructor(factory: SimplePizzaFactory) {
    this.factory = factory
  }
  
  orderPizza(type: string): Pizza {
    const pizza: Pizza = factory.createPizza(type)
    ...
    return pizza
  }
}
```
- new 연산자 대신 팩토리 객체에 있는 create 메서드를 썼다. 이제 더 이상 구상 클래스의 인스턴스를 만들 필요가 없다.
- 이렇게 함으로써 피자 생성하는 작업을 한 클래스에 캡슐화함으로써 구현을 변경하는 경우에 이 팩토리 클래스 하나만 고치면 된다.
- 객체 구성을 활용하면 행동을 실행시에 바꿀 수 있다. 구현된 객체를 바꿀 수 있기 때문이다. 지금은 SimplePizzaFactory 뿐이지만 후에 PizzaFactory 상위 형식이 생기면 상위 형식을 구현한 PizzaFactory들로 바꿀수 있다.
- 지금까지 만든 애플리케이션의 다이어그램을 보자.
![1_ruaoLSRRkNr2BpvE6RrOxQ](https://user-images.githubusercontent.com/48785060/139679796-7079f60d-e2c1-4130-9b3a-623db3a125ff.png)
- PizzaStore은 팩토리를 사용하는 클랑이언트며 SimplePizzaFactory를 통해 Pizza 인스턴스를 받게된다.
- SimplePizzaFactory는 피자 객체를 생성하는 팩토리며 이 앱에서 유일하게 구상 Pizza 클래스를 직접 참조하는 부분이다.

3. 이제 다른 지역에도 프랜차이저를 운영하게 됐고 지역마다 조금씩 다른 차이점을 적용해보려고 한다.
- PizzaStore에서 적당한 팩토리를 사용하게 지역별 팩토리를 만들자.
```
const nyFactory: NYPizzaFactory = new NYPizzaFactory()
const nyStore: PizzaStore = new PizzaStore(nyFactory)
nyStore.order('Veggie')

const chicagoFactory: ChicagoPizzaFactory = new ChicagoPizzaFactory()
const chicagoStore: PizzaStore = new PizzaStore(chicagoFactory)
chicagoStore.order('Veggie')
```
- 근데 분점마다 지역별 팩토리를 사용하기는 하지만 독자적인 방법들을 사용하기 시작했다. 따라서 피자 가게와 피자 제작 과정 전체를 하나로 묶어주는 프레임워크를 만들어야 겠다는 결론에 도달했다.
- 첫번째 방법에서는 피자를 만드는 고드가 PizzaStore와 직접 연결되어 있긴 했지만 유연성은 없었따. 유연성도 유지하면서 피자 만드는 과정도 PizzaStore에 연결시켜줘야 한다.

4. PizzaStore 안에 피자를 만드는 코드를 집어넣어 피자 가게와 피자 제작 과정 전체를 묶어주자.
```
abstract class PizzaStore {
    orderPizza(type: string): Pizza {
        const pizza = this.createPizza(type)
        ...
        return pizza
    }

    abstract createPizza(type: string): Pizza
}
```
- PizzaStore에서 createPizza 메서드로 피자 인스턴스를 만드는데 추상 메서드로 선언하여 PizzaStore의 서브 클래스에서 구현하도록 했다.
- 팩토리 객체 대신 createPizza 메서드로 피자 인스턴스를 생성한다.
- 이제 각 분점을 위한 서브 클래스가 구현돼야 하고 피자의 스타일은 각 서브 클래스에서 결정한다.
- 지역별로 빵을 얇게 한다던가 하는 변경사항을 createPizza() 메서드 안에 넣어 구현함으로써 이 메서드에서 각 분점별로 달라지는 스타일을 모두 책임지도록 한다.
- 이제 PizzaStore 프레임워크에 충실하면서 각각의 스타일을 제대로 구현할 수 있는(서브클래스에서 구현된 createPizza()로) orderPizza() 메서드를 가지고 있는 PizzaStore 서브 클래스들을 구비할 수 있다.
- orderPizza()는 서브클래스가 아닌 PizzaStore 추상클래스에서 정의한다. 따라서 orderPizza() 메서드에서는 실제로 어떤 서브클래스(구상클래스)에서 이 코드를 실행시키고 피자를 만드는지 알 수 없다.
    -> PizzaStore와 Pizza는 서로 완전히 분리돼 있다.
- orderPizza()에서 createPizza()를 호출하면 PizzaStore의 Pizza의 서브 클래스들이 피자를 만든다. NYPizzaFactory에서는 뉴욕풍 피지가 만들어질 것이다.
- 만을어지는 Pizza는 PizzaStore의 서브클래스 종류에 따라 결정되므로 만들어지는 피자의 종류가 PizzaStore의 서브클래스에서 결정된다고 볼 수 있다.
- Pizza 인스턴스를 만드는 일은 이제 팩토리 역할을 하는 createPizza() 메서드에서 맡아서 처리한다. => 팩토리 메서드 패턴
5. PizzaStore을 구현해보자.
```
class NYPizzaStore extends PizzaStore {
    createPizza(item: string): Pizza {
        const pizza: Pizza = item === 'cheese' ? new NYStyleCheesePizza() : 'veggie' ? new NYStyleVeggiePizza() : new NYStylePepperoniPizza()
        return pizza
    }
}
```
- PizzaStore의 구상클래스의 createPizza() 메서드에서 어떤 피자 인스턴스를 리턴할지는 PizzaStore의 서브클래스에서 결정된다.
- 여기까지 오면서 구상 클래스(Pizza의 구상 클래스)의 인스턴스를 만드는 일을 한 객체에서 전부 처리하는 방식에서 일련의 서브클래스에서 처리하는 방식으로 넘어오게 됐다.

### 팩토리 메서드 (abstract factoryMethod(type: string): Product)
- 팩토리 메서드는 객체 생성을 처리하며, 팩터리 메서드를 이용하면 객체를 생성하는 작업을 서브클래스에 캡슐화시킬 수 있다.
- 이렇게 하면 슈퍼클래스에 있는 클라이언트 코드(ex. PizzaStore의 orderPizza())와 서브 클래스에 있는 객체 생성 코드를 분리시킬 수 있다. 
- 팩토리 메서드는 추상메서드로 선언하여 서브클래스에서 객체 생성을 책임지도록 한다.
- 팩토리 메서드에서는 특정 객체를 리턴하며, 그 객체는 보통 슈퍼클래스에서 정의한 메서드 내에서 쓰이게 된다.
- 팩토리 메서드는 클라이언트에서 실제로 실제로 생성되는 구상 객체가 무엇인지 알 수 없게 만드는 역할도 한다(Pizza라는 형식만을 알 뿐 어떤 Pizza인지는 모른다.).

### 팩토리 패턴
- 모든 팩토리 패턴에서는 객체 생성을 캡슐화 한다.(서브 클래스에 위임한다.)
- 팩토리 메서드 패턴에서는 서브클래스에서 어떤 클래스를 만들지 결정하게 함으로써 객체 생성을 캡슐화했다.
- PizzaStore을 통해 팩토리 메서드 패턴이 팩토리 메서드와 결합된 orderPizza() 메서드를 제공하는 형태의 프레임워크라는 것을 알았다.
- 제품에 대한 지식을 각 생산자에 캡슐화하는 방법에 초점을 맞춰 이 패턴을 바라볼 수도 있다. 예를 들어 NYPizzaStore에는 뉴욕풍 피자를 만드는 것에 대한 모든 지식이 캡슐화 돼 있다. 팩토리 메서드는 이러한 지식을 캡슐화시키는데 있어서 가장 핵심적인 역할을 맡고있다.

### 팩토리 메서드 패턴의 정의
- 팩토리 메서드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만든다. 팩토리 메서드 패턴을 이용하면 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡긴다.
![Factory](https://user-images.githubusercontent.com/48785060/139689989-8b4c6cf3-b05d-4370-b89b-75f4d227dc74.png)
- Creator 추상 클래스에서 팩토리 페서드를 위한 인터페이스를 제공한다. Creator 서브클래스에서 이 메서드를 구현해야 한다.
- Creator 추상 클래스에 정의된 anOperation() 메서드에서 factoryMethod()를 사용해서 인스턴스를 받는데 Creator 클래스 자체가 생산될 제품에 대한 사전 지식이 없기 때문에 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다라고 주로 말한다.
- Product 클래스에서는 모두 똑같은 인터페이스를 구현해야지 그 제품을 사용할 클래스에서 구상 클래스가 아닌 인터페이스에 대한 레퍼런스를 써서 객체를 참조할 수 있다(유연성)

### 간단한 팩토리 vs 팩토리 메서드 패턴
- 간단한 팩토리는 일회용 처리에 불과한 반면, 팩토리 메서드 패턴을 이용하면 어떤 구현을 사용할지는 서브클래스에서 결정하는 프레임워크를 만들 수 있다.
- 간단한 팩토리는 객체 생성을 캡슐화하는 방법을 사용하긴 하지만 팩토리 메서드 패턴처럼 강력한 유연성을 제공하지는 못한다. 생성하는 제품을 마음대로 변경할 수 없기 때문이다.

### 의존성 역전 원칙
- 구상 클래스에 대해 의존하지 않게 한다.
- 추상화된 것에 의존하도록 만든다.
- 고수준 구성요소가 저수준 구성요소에 의존하면 안된다.

### 고수준 구성요소와 저수준 구성요소
![140fig01 png](https://user-images.githubusercontent.com/48785060/139691656-d04d1bb7-da79-4053-aef3-309335934440.jpg)
- 고수준 구성요소는 다른 저수준 구성요소에 의해 정의되는 행동이 들어있는 구성요소를 뜻한다.
- PizzaStore의 행동은 Pizza에 의해 정의되기 때문에 PizzaStore은 고수준 구성요소, Pizza 객체들은 저수준 구성요소라고 할 수 있다.

### 팩토리 메서드 패턴과 의존성 역전
![download](https://user-images.githubusercontent.com/48785060/139692164-d8dc72d7-78f3-4432-a1ac-7d35d429117f.jpg)
- PizzaStore은 추상 클래스인 Pizza에 의존하게 된다. (어떤 Pizza 구상 클래스의 인스턴스가 오는지 모른다. 다만 아는건 상위 형식인 Pizza 라는 사실일 뿐이다.)
- Pizza 구상클래스들도 Pizza 추상 클래스에 의존하게 된다.
- 팩토리 메서드 패턴을 적용하면 고수준 구성요소인 PizzaStore와 저수준 구성요소인 피자 객체들이 모두 추상 클래스인 Pizza에 의존한다는 것을 알 수 있다.

### 의존성 역전 원칙을 지키는데 도움이 될만한 가이드라인
- 어떤 변수에도 구상 클래스에 대한 레퍼런스를 저장하지 말자. -> new 연산자를 사용하면 구상 클래스에 대한 레퍼런스를 사용하게 된다. 팩토리를 써서 구상 클래스에 대한 레퍼런스를 변수에 저장하는 일을 미리 방지하자.
- 구상 클래스에서 유도된 클래스를 만들지 말자. -> 구상 클래스에서 유도된 클래스를 만들면 특정 구상 클래스에 의존하게 된다. 인터페이스나 추상클래스처럼 추상화된 것으로부터 클래스를 만들어야 한다.
- 베이스 클래스에 이미 구현되어있는 메서드를 오버라이드하지 말자. -> 베이스 클래스에서 메서드를 정의할대는 모든 서브클래스에서 공유할 수 있느 것만 정의하자.

### 피자 만드는데 이제 같은 지역의 분점들끼리 동일한 재료를 사용하게 하고 싶다
- 원재료 팩토리를 위한 인터페이스를 만들고 각 지역의 원재료 팩토리들이 그것을 구현하게 하자.
- 그리고 Pizza 구상 클래스 만들때 생성자로 원재료 팩토리 인스턴스를 넘겨(이때도 상위 형식으로 저장해 유연하게 하도록 하자) 원재료를 만들자.
- 이제 피자 생성과 재료 생성이 분리됐다. 만들어지는 재료는 어떤 원재료 팩토리를 쓰는지에 따라 달라진다. 피자 클래스는 피자를 만드는 방법만을 알고 있을 뿐이다.

### 추상 팩토리
- 피자가게는 추상 팩토리라고 부르는 새로운 형식의 팩토리를 도입해서 서로 다른 피자에 필요로 하는 원재료군을 생산하기 위한 방법을 구축했다.
- 추상팩토리를 통해서 제품군을 생성하기 위한 인터페이스를 제공할 수 있다. 이 인터페잇르르 이용하는 코드를 만들면 코드를 제품을 생산하는 실제 팩토리와 분리시킬 수 잇다.
- 피자를 만드는 클라이언트 코드는 전혀 바뀔 필요가 없이 원재료 팩토리를 여러개 전달하면서 다양한 피자를 만들 수 있게 된다.

### 추상 팩토리 정의
- 제품군을 만들때 쓸 수 있는 패턴이다.
- 추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다.
- 추상 팩토리를 사용하면 클라이언트에서 추상 인터페이스를 통해 일련의 제품들을 공급받을 수 있다. 클라이언트 어떤 제품이 생산되는지도 전혀 알 필요도 없고 따라서 클라이언트와 팩토리에서 생산되는 제품을 분리시킬 수 있다.
![UML-Class-diagram-describing-the-AbstractFactory-pattern](https://user-images.githubusercontent.com/48785060/139695344-df8b70ec-23c0-46d1-8689-c7f6c0429f24.png)
- 클라이언트를 만들때 AbstractFactory를 바탕으로 만든다. 실제 팩토리는 실행중에 결정된다.

### 추상팩토리와 팩토리 메서드 패턴
- 팩토리 메서드 패턴은 상속을 통해서 객체를 만든다. 팩토리 메서드를 통해 객체를 형성할때는 클래스를 확장하고 팩토리 메서드를 오버라이드해야 한다. 팩토리 메서드 패턴을 사용한다는 것은 결국 서브클래스를 통해 객체를 만들기 위한 것이다. 클라이언트(팩토리 메서드를 호출하는 부분)에서는 자신이 사용할 추상 형식만 알면된다. 구상 형식은 서브클래스에서 처리한다. 클라이언트와 구상형식을 분리시켜준다.
- 추상 팩토리는 객체 구성(composition)을 통해 객체를 만든다. 제품군을 만들기 위한 추상형식을 제공하고 제품이 생산되는 방법은 이 형식의 서브클래스에서 정의된다. 팩토리를 이용하고 싶으면(추상 팩토리 인터페이스) 인스턴스를 만든 다음(추상 팩토리 인터페이스를 구현해야한다.) 추상 형식을 써서 만든 코드에 전달하면 된다.
따라서 클라이언트와 클라이언트에서 사용하는 실제 구상 제품이 분리된다.(클라이언트는 추상 팩토리 인터페이스 형식만 안다)
- 클라이언트에서 일련의 연관된 제품들을 생성할때는 추상 팩토리 패턴을 사용하자.
- 클라이언트 코드와 인스턴스를 만들어야 할 구상클래스를 분리시킬때는 팩토리 메서드 패턴을 활용하자. 어떤 구상 클래스를 필요로 할지 미리 알 수 없는 경우에도 팩토리 메서드 패턴은 유용하다.

### 팩토리 패턴 핵심 정리
- 팩토리를 쓰면 객체 생성을 캡슐화 할 수 있다.
- 팩토리 메서드 패턴에서는 상속을 활용한다. 객체 생성이 서브클래스에 위임된다. 서브클래스에서 팩토리 메서드를 구현하여 객체를 생성한다.
- 추상 팩토리 패턴에서는 객체 구성을 활용한다. 객체 생성이 팩토리 인터페이스에서 선언한 메서드들에서 구현된다.
- 모든 팩토리 패턴에서는 애플리케이션의 구상 클래스에 대한 의존성을 줄여준다.
- 의존성 역전을 사용하면 구상 형식에 대한 의존을 피하고 추상화를 지향할 수 있다.
- 팩토리는 수아 클래스가 아닌 추상 클래스/인터페이스에 맞춰서 코딩할 수 있게 해주는 기법이다.

# design-pattern

### 다양한 오리들의 종류를 만들고 싶다. 어떤 방법을 사용해야 할까?

1. 그럼 Duck이라는 class를 만들고 이 클래스를 상속받아서 다양한 오리들을 만들면 되지 않을까?

```
class Duck {
    fly() {
        console.log('fly)
    }
}

class WildDuck extends Duck {}
```

- 근데 이렇게 확장을 사용해서 오리들을 구현하게 되면 만약 RubberDuck 처럼 날 수 없는 오리들이 있다면 일일히 다 오버라이드를 해서 수정을 해줘야 한다.
  <br>-> 따라서 상속은 좋은 방법이 아니다. 일부 형식의 오리만 날거나 꽥꽥거릴 수 있게 해야 한다. (상속은 좋은 방법은 아니다.)

```
class Duck {
    fly() {
        console.log('fly)
    }
}

class WildDuck extends Duck {
    fly() {
        // do nothing
    }
}
```

2. 그럼 인터페이스를 사용해보는 것은 어떨끼? fly()를 Duck에서 빼서 Flyable 인터페이스를 만들고 날 수 있는 오리를 만들때 이 인터페이스를 구현하게 하는 것이다.
   <br>-> 근데 이렇게 하게 되면 날 수 있는 오리들이 날 수 없는 오리보다 더 많을텐데 상속 사용하면서 날 수 없는 오리들에서 fly 오버라이드 하는 것보다 더 많은 코드 수정이 이뤄져야 한다. (이것도 좋은 방법은 아니다.) 또한 구현조자 구상클래스에서 하기 때문에 코드의 재사용성 또한 기대하기 어렵다.

```
interface Flyable {
    fly(): void
}
class WildDuck implements Flyable {
    fly() {
        console.log('fly')
    }
}
class RubberDuck {
}
```

<br>

### 디자인 원칙: 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다. 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 '캡슐화' 한다.

- 이 개념은 다른 모든 디장니 패턴의 기반을 이루는 원칙이다. 모든 패턴은 '시스템의 일부분을 다른 부분과 독립적으로 변화 시킬 수 있는' 방법을 제공하기 위한 것이다.

<br>

### 바뀌는 부분과 그렇지 않은 부분 분리하기

- fly()와 quack() 문제를 제외하면 Duck 클래스는 잘 동작한다. 이 두개를 제외하면 잘 바뀌지 않는다.
- 그럼 변화하는 부분인 fly()와 quack()를 작업 들어가자. 이 두 개를 두 개의 클래스 집합으로 만들자. 하나의 집합은 나는 것과 관련된 클래스 집합(빨리 날기, 느리게 날기, 높게 날기, ...)와 빽빽거리는 것과 관련된 클래스 집합(크게 뺵빽, 작게 뺵뺵, ...)이다.

```
inteface FlyBehavior {
    fly(): void
}
class FlyWithWings implements FlyBehavior {
    fly() {
        console.log('Fly with wings')
    }
}
class FlyNoWay implements FlyBehavior {
    fly() {}
}
```

- 유연하게 만들자. Duck 인스턴스에 행동을 할당할 수 있게 만들고, 또 오리의 행동을 동적으로 바꿀 수 있으면 좋겠다.

<br>

### 디자인 원칙: 구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다.

- 이제 Duck 행동은 특정 행동 인터페이스를 구현한 별도의 클래스 안에 있게 된다. Duck 클래스는 이제 그 행동이 어떻게 구현되는지 몰라도 된다. 다만 어떤 행동 인터페이스만 사용하는지 알면 된다.
- 인터페이스에 맞춰 프로그래밍 한다라는 것은 상위 형식에 맞춰 프로그래밍한다를 말한다. 변수를 선어할때 보통 추상 클래스나 인터페이스 같은 상위 형식으로 선언해야 한다. 객체를 변수에 대입할때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 집어넣을수 있기 때문이다.

<br>

### 행동을 Duck 클래스에서 뺴서 다른 클래스에 위임했다.

- 이런 식으로 디자인 하면 다른 형식의 객체에서도 이 행동들을 재사용할수 있다. 이 행동들이 더 이상 Duck 클래스에 숨겨져 있지 않기 때문이다.
- 각 오리에는 FlyBehavior와 QuackBehavior이 있으며 각각 나는 행동과 꽥꽥 행동을 위임받는다.

<br>

### 디자인 원칙: 상속보다는 구성을 활용한다.

- A에는 B가 있다. 각 오리에는 FlyBehavior와 QuackBehavior이 있으며 각각 나는 행동과 우는 행동을 위임받는다.
- 두 클래스를 이런 식으로 합치는 것을 구성(composition)을 이용한다고 한다. 오리 클래스에서는 올바른 행동 객체로 구성됨으로서 행동을 부여받게 된다.
- 구성을 이용하게 되면 유연성을 크게 향상시킬 수 있다.

# design-pattern

# Adapter and Facade Pattern

## Adapter Pattern

### 어댑터 패턴은

- 객체지향 어댑터는 어떤 인터페이스를 클라이언트에서 요구하는 형태의 인터페이스에 적응시켜주는 역할을 한다.

<br>

### 어댑터 패턴이 작동하는 방식

1. 클라이언트에서 타겟 인터페이스(기존 목적에 맞는 인터페이스)를 사용하여 메서드를 호출함으로써 어댑터에 요청을 한다.
   - 클라이언트는 타겟 인터페이스에 맞게 구현돼 있다.
2. 어댑터에서는 클라이언트에서 온 요청을 받고 어댑티 인터페이스를 사용하여 그 요청을 어댑티에 대한 (하나 이상의) 메서드 호출로 변환한다. (어댑티는 클라이언트와 정반대에 위치해 있는 것을 말한다.)
   - 어댑티는 타겟 인터페이스를 구현하며 어댑터는 어댑티 인스턴스가 들어있다.
3. 클라이언트는 호출 결과를 받지만 중간에 어댑터가 껴 있는지는 전혀 알지 못한다.
   - 어댑터는 타겟 인터페이스 형식이기 때문에 클라이언트는 타겟 인터페이스 쓰듯이 그대로 쓰기만 하면 된다.
   - 클라이언트와 어댑티는 서로 분리돼 있으며 서로에 대해 전혀 몰라도 된다.

<br>

### 어댑터 패턴의 정의

- 어댑터 패턴은 한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다. 어댑터를 이용하면 인터페이스 호환성 문제 떄문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.
- 이 패턴을 활용하면 클라이언트와 구현된 인터페이스를 분리시킬 수 있으며 나중에 인터페이스가 바껴도(아마 어댑티 인터페이스) 그 변경 내용은 어댑터에 캡슐화되기 때문에 클라이언트는 바뀌지 않아도 된다.

![42f2dae821df0721338fa191ab8b3cd6](https://user-images.githubusercontent.com/48785060/141647196-544c18d2-02c2-4a6b-a5eb-f15f060c6995.gif)

- 어댑터에서는 타겟 인터페이스를 구현한다.
- 어댑터는 어댑티로 **구성**돼 있다.
- 모든 요청은 어댑티에게 위임된다.
- 어댑터는 구성을 활용하여 어댑티 인스턴스를 받기 떄문에 어댑티 인터페이를 구현하는 모든 클래스는 어댑터를 사용할 수 있다.

<br>

## Facade Pattern

### 목적

- 인터페이스를 단순화시키기 위해서 인터페이스를 변경한다.

<br>

### 복잡한 홈씨어터

![1_LH2e5s55oLQj3tkYYSk73w](https://user-images.githubusercontent.com/48785060/141649319-a0975ae4-3ae3-46d5-b67f-e759baae8a55.png)

- 각 클래스들이 여러 클래스들을 서로 구성요소로 가지고 있으면서 복잡하게 얽혀있다.

<br>

### 퍼사드 패턴을 쓰게 되면

- 퍼사드 패턴을 쓰면 훨씬 쓰기 쉬운 인터페이스를 제공하는 퍼사드 클래스를 구현함으로써 복잡한 시스템을 훨씬 쉽게 사용할 수 있다.

![unnamed](https://user-images.githubusercontent.com/48785060/141649394-59b0366a-205d-4877-b72c-50acf3931e2d.png)

- 퍼사드 클래스에는 홈 씨어터의 구성요소들을 하나의 서브시스템으로 간주파고, 파사드 클래스에 정의된 메서드들을 호출하면 서브시스템의 메서드들을 호출하여 필요한 작업들을 처리한다.
- 퍼사드를 쓰더라도 서브시스템에는 직접 접근할 수 있기 때문에 서브시스템의 기능들을 사용할 수 있다.
- 퍼사드 클래스는 서브시스템 클래스들을 캡슐화하는 것이 아니고 서스시스템의 기능을 사용할 수 있는 간단한 인터페이스를 제공할 뿐이다.
- 퍼사드 크래스에서는 서브시스템 기능을 사용하면서도 추가로 기능을 추가할 수도 있다.
- 퍼사드 패턴을 사용하면 클라이언트 구현과 서브시스템을 분리시킬 수 있다. 서브 시스템 인터페이스에 변경이 생기면 클라이언트는 변경할 필요 없이 파사드 클래스만 변경하면 된다.

<br>

### 어댑터 패턴와 파사드 패턴

- 어댑터 패턴은 인터페이스를 변경하여 클라이언트에서 필요로 하는 인터페이스를 적용하는 용도로 쓰인다.
  -> 타겟 인터페이스와 다른 형식을 가진 인터페이스를 타겟 인터페이스에 맞게 동작하게 만든다.
- 파사드 패턴은 어떤 서브 시스템에 대한 간단한 인터페이스를 제공하는 용도로 쓰인다.

<br>

### 퍼사드 패턴의 정의

어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다. 퍼사드에서 고수준 인터페이스를(많은 구현 클래스에 의존) 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있다.

<br>

### 디자인 원칙 "최소 지식 원칙": 정말 친한 친구하고만 얘기해라 (데메테르의 원칙)

```
// 원칙을 지키지 않은 경우
function getTemp() {
// station으로부터 thermometer 객체를 받았고 이 겍체의 메서드를 직접 호출한다.
const thermometer: Thermometer = station.getThermometer();
return thermometer.getTemperature();
}

// 원칙을 지킨 경우
function getTemp() {
// Station 클래스에 getTemperature() 메서드를 추가함으로써 의존해야 하는 클래스 개수를 줄였다.
return station.getTemperature();
}
```

- 시스템을 디자인할떄 어떤 객체든 그 객체와 상호작용을 하는 클래스의 개수에 주의해야 하며, 그런 객체들과 어떤 식으로 상호작용을 하는지에도 주의를 기울여야 한다.
- 이 원칙을 지키기 위해서는 다음 네 종류의 메서드만 호출하자.
  - 객체 자체
  - 메서드에 매개변수로 전달된 객체
  - 그 메서드에서 생성하거나 인스턴스를 만든 객체
  - 그 객체에 속하는 구성요소

```
class Car {
  engine: Engine; // 이 클래스의 구성요소. 이 구성요소의 메서드는 호출해도 된다.

  constructor() {
    // ...
  }

  updateDashboardDisplay() {
    // ...
  }

  start(key: Key) {
    const doors = new Doors(); // 새로운 객체를 생성한다. 이 객체의 메서드는 호출해도 된다.
    const authorized = key.turns(); // 매개변수로 전달된 key의 메서드들은 호출해도 된다.
    if (authorized) {
      this.engine.start(); // 구성요소의 메서드는 호출해도 된다.
      this.updateDashboardDisplay(); // 객체 내에 있는 메서드는 호출해도 된다.
      this.doors.lock(); // 직접 생성하거나 인스턴스를 만든 객체의 메서드는 호출해도 된다.
    }
  }
}
```

### 정리

- 기존 클래스를 사용하려고 하는데 인터페이스가 맞지 않으면 어댑터 패턴을 쓰면 된다.
- 큰 인터페이스, 또는 여러 인터페이스를 단순화시키거나 통합해야 하는 경우 퍼사드 패턴을 쓰면 된다.
- 어댑터는 타겟 인터페이스를 클라이언트에서 원하는 인터페이스로 바꿔주는 역할을 한다.
  - 클라이언트에서 원하는 인터페이스를 구현한 객체를 구성요소로 가짐으로써 수행한다.
- 파사드 패턴은 클라이언트를 복잡한 서브시스템과 분리시키는 역할을 한다.
- 어댑터 패턴은 객체를 감싸서 인터페이스를 바꾸기 위한 용도로, 데코레이터 패턴은 객체를 감싸서 새로운 행동을 추가하기 위한 용도로, 파사드 패턴은 일련의 객체들을 감싸서 단순화시키기 위한 용도로 쓰인다.

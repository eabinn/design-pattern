# Command Pattern

### 식당을 예로 들어보자.

- 고객 -> createOrder() -> 주문서 Order -> takeOrder() -> 웨이트리스 -> orderUp() -> 주방장 -> makeBurger(), makeDrink() -> 결과물
- 주문서는 주문한 메뉴를 캡슐화한다.
  - 주문서는 주문한 메뉴를 요구하는 역할을 하는 객체로 생각할 수 있다.
  - 이 객체의 인어페이스에는 orderUp()이라는, 식사를 준비하기 위한 행동을 캡슐화한 메서드가 들어있다. 유일한 메서드다.
  - 그리고 식사를 주문해야 하는 객체(주방장)에 대한 레퍼런스도 들어있다. -> 행동은 캡슐화 돼 있다.(ex. cooker.cook())
- 웨이트리스는 주문서를 받아 orderUp() 메서드를 호출한다.
  - 주문서를 받고 orderUp() 메서드만 호출한다. 그리고 결과를 받는다. 세부 내용은 알 필요가 없다. 캡슐화 돼 있다.
  - 웨이트리스의 takeOrder() 메서드에는 여러 주문서를 매개변수로 받지만 주문서는 orderUp() 이라는 하나의 메서드만을 가진 인터페이스를 구현하고 있으므로 웨이트리스는 여러 개의 주문서를 받아도 orderUp() 하면 된다.
- 주방장은 식사를 준비하는데 필요한 정보를 가지고 있다.
  - 웨이트리스가 orderUp()을 호출하면 주방장은 음식을 만들기 위한 메서드를 전부 처리한다. 여기서 웨이트리스와 주방장이 완전히 분리돼 있다는 것을 알 수 있다.
  - 웨이트리스는 주문서의 orderUp() 메서드를 호출할 뿐이고, 주방장은 주문서로부터 할 일을 전달 받는다.

### 식당과 커맨드 패턴

- 클라이언트 -> createCommandObject() -> Command Obejct -> setCommand() -> 인보커 -> execute() -> 리시버의 action1(), action2() ...
- 클라이언트는 커맨드 객체를 생성한다. 커맨드 객체는 리시버에 대한 레퍼런스가 저장돼 있고 execute()시 리시버가 해야할 메서드들이 정의돼 있다.
- 클라이언트에서 인보커(invoker) 객쳉ㅇ의 setCommand()메서드를 호출, 이때 커멘드 객체를 넘겨준다. 그 객체는 쓰이기 전까지는 인보커 객체에 보관된다.
- 인보커에서 커맨드 객체의 execute()메서드를 호출하면 리시버에 있는 특정 행동을 위한 메서드가 실행된다.

### 불을 켜는 기능을 가진 리모컨을 만들어보자.

1. Command 인터페이스를 만들자.

- 커맨드 객체는 모두 같은 인터페이스를 구현해야 한다.

```
interface Command {
    execute(): void
}
```

2. 커맨드 객체를 구현해보자.

- 예는 전등을 켜기 위한 커맨드 클래스다.

```
class LightOnCommand implements Command {
    private light: Light

    constructor(light: Light) {
        this.light = light
    }

    execute():void {
        this.light.on()
    }
}
```

- 생성자에 커맨드 객체로 제어할 특정 전등에 대한 레퍼런스가 전달된다.
- 그 객체는 light 변수에 저장되고 execute() 메서드가 호출되면 light객체가 바로 그 요청에 대한 리시버(Receiver)가 된다.

3. 커맨드 객체 사용하기

```
class SimpleRemoteControl {
    slot?: Command // 커맨드를 집어넣을 슬록

    constructor() {}

    setCommand(command: Command) { // 슬롯을 제어할 명령을 설정하기 위한 메서드
        this.slot = command
    }

    buttonWasPressed() { // 버튼이 눌리면 슬롯의 execute() 메서드를 실행한다.
        this.slot?.execute()
    }
}
```

### 커맨드 패턴의 정의

- 커맨드 패턴을 이용하면 요구 사항을 객체로 캡슐화할 수 있으며, 매개변수를 써서 열ㄹ러 가지 다른 요구사항을 집어넣을 수도 있다.
- 또한 요청 내용을 큐에 저장하거나 로그로 기록할 수도 있고, 작업취소 기능도 가능하다.
- 커맨드 객체는 일련의 행동을 특쩡 리시버하고 연결시킴으로써 요구 사항을 캡슐화한 것이다.
- 행동과 리시버를 한 객체에 집어넣고, execute()라는 메서드 하나만 외부에 공개한다. 이 메서드 호출에 의해 리시버에서 일련의 ㅉㅉ짝업이 처리된다.
- 외부에서 볼때는 어떤 객체가 리시버 역할을 하는지, 그 리시벙ㅇㅇ에서 실제로 어떤 일을 하는지 알 수 없다. 그냥 execute() 호출하면 요구 사항이 처리된다는 것만 알 수 있을 뿐이다.
- 웨이트리스가 여러 개의 주문서를 받고, 여러 명령을 받은 슬롯이 있어도 하나의 커맨드 인터페이스를 구현하고 있단걸 알고 있으니 여러 개의 객체가 있어도 execute() 하면 된다는 것을 안다.

### 커맨드 패턴의 정의: 클래스 다이터그램

![unnamed](https://user-images.githubusercontent.com/48785060/140636323-5d51b019-05ca-4f81-8924-98665e3f3a57.png)

- Client는 ConcreateCommand를 만들고 Receiver을 설정한다. Receiver는 요구 사항을 수행하기 위해 어떤 일을 처리해야 하는지 알고 있는 객체다.
- Invoker에는 명령이 들어있으며 execute()를 메서드를 호출함으로써 커맨드 객체에게 특정 작업을 수행해달라는 요구를 하게 된다.
- Command는 모든 커맨드 객체에서 구현해야 하는 인터페이스다. 모든 명령 객체는 execute() 메서드 호출을 통해 요구사항을 수행한다.
- ConcreteCommand는 특정 행동과 리시버 사이를 연결해준다.
- Invoker에서 execute() 호출을 통해 요청을 하면 ConcreateCommand 객체에서 리시버에 있는 메서드를 호출함으로써 그 작업을 처리한다.

### 질문

1. 리시버가 필요하나? 커맨드 객체에서 execute()를 구현하면 되지 않나?
   : 그렇게 하면 인보커와 리시버를 분리시키는 것이 불가능해지고, 리시버를 이용해 커맨드를 매개변수화 할 수 없다. (?)

### 커맨드 패턴 활용: 요청을 큐에 저장하기

- 커맨드를 이용하면 컴퓨테이션의 한 부분(리스버와 일련의 행동)을 패키지로 묶어서 일급 객체 형태로 전달할 수 있다. 그리고 클라이언트는 커맨드 객체 생성 후에도 그 컴퓨터이션을 호출할 수 있다. 또한 다른 스레드에서 호출하는 것도 가능하다.
- 이런 시나리오는 스케줄러나 스레드 풀, 작업 큐와 같은 다양한 용도에 적용할 수 있다.
- 작업 큐에서는 한쪽 끝에서는ㄴ 커맨드를 추가, 다른 한쪽 끝에는 커맨드를 처리하기 위한 스레드들이 대기하고 있따. 각 스레드에서는 우선 execute() 메서드를 호출하고 그 호출이 완료되면 새로운 커맨드 객체를 가져온다.
- 작업 큐 클래스는 컴퓨팅 작업을 하는 객체들과 완전히 분리돼있다. 작업 큐에서는 커맨드를 가져오고 execute()만 실행하면 된다.

### 커맨드 패턴 활용: 요청을 로그에 기록하기

- 애플리케이션에서 모든 행동을 기록해뒀다가 다운됐을때 그 행동들을 다시 호출해서 복구할수 있게 해야한다. 커맨드 인터페이스에 store() 와 load()라는 메서드를 추가해서 구현할수 있다.
- 각 커맨드가 실행될때마다 디스크에 그 내역을 store() 하고 시스템이 다운돼면 객체를 다시 load() 해서 순서대로 작업을 처리하면 된다.

### 핵심정리

- 커맨드 패턴을 이용하면 요청을 처리하는 객체와 그 요청을 수행하는 객체를 분리시킬 수 있다.
- 분리 과정의 중심에 커맨드 객체가 있으며 이 객체가 행동이 들어있는 리시버를 캡슐화한다.
- 인보커에서는 커맨드 객체의 execute()만 실행하면 된다. execute()메서드에서는 리시버에 있는 행동을 호출한다.
- 인보커는 커맨드를 통해서 매개변수화 될 수 있으며 실행중에 동적으로 설정할 수 있다.
- 요청 자체를 리시버에게 넘기지 않고 자기가 처리하는 "스마트" 커맨드 객체를 사용하는 경우도 있다.
- 커맨드 패턴을 활요하여 로그 및 트랜잭션 시스템을 구현하는 것도 가능하다.

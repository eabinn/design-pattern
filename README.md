# design-pattern

# Template Method Pattern

### 목적

일정한 프로세스를 가진 요구사항을 템플릿 메서드 패턴을 사용해 구현할 수 있다.<br>
구현하라는 알고리즘의 순서를 가지고 있고 변경가능성이 있을떄 사용한다.<br>
(템플릿이란 단순히 메서드에 불과하다. 일련의 단계들로 알고리즘을 정의한 메서드다.)

<br>

### 템플릿 메서드 패턴의 정의

메스드에서 알고리즘의 골격(구조)를 정의한다. 알고리즘의 여러 단계 중 일부는 서브클래스에서 구현할 수 있다. 템플릿 메서드를 이용하면 알고리즘의 구조는 그대로 유지하면서 서브 클래스에서 특정 단계를 재정의할 수 있다.

![71810981-f9b82f00-30b6-11ea-9c8a-47512a75e21d](https://user-images.githubusercontent.com/48785060/141605756-107016d0-d72d-406b-b059-e5cd3e9c1998.png)

```
abstract class AbstractClass {
    protected templateMdthod(): void {
        this.primitiveOperation1()
        this.primitiveOperation2()
        this.concreteOperation()
    }

    abstract primitiveOperation1(): void
    abstract primitiveOperation2(): void

    concreteOperation() {
        // concreteOperation method code
    }
}
```

- AbstractClass에 템플릿 메서드가 들어있다.
- abstract 메서드로 선언된 단계들이 템플릿 메서드에서 활용된다. 템플릿 메서드에서는 알고리즘을 구현할때 primitiveOveration1()와 2()를 활용한다. 알고리즘 자체(템플릿 메서드)는 이 단계들이 구체적인 구현으로부터 분리돼 있다.
- abstract로 선언되었던 단계들은 ConcreteClass에서 구현한다.
- 템플릿 메서드에서는 각 단계들을 순서대로 정의하는데, 각 단계는 메서드로 표현된다.

<br>

### 후크

후크는 추상 클래스에서 선언되는 메소드이긴 하지만 기본적인 내용만 구현돼 있거나 아무 코드도 들어있는 않은 메서드다. 아무 의미도 없기 때문에 서브클래스에서 후크를 오버라이드 할 수도 있고 안 할수도 있다.

<br>

### 후크 활용

- 후크를 사용하려면 서브클래스에서 오버라이드 해야한다.
- 알고리즘의 특정 부분이 선택저으로 적용된다 하는 경우에 후크를 사용하면 된다.
- 템플릿 메서드가 있는 추상 클래스에서 일련의 여러 단계들을 전부 다 구현해두고 후크를 활용해 그 단계들을 스킵하거나 진행할지를 결정할 수도 있다.

<br>

### 디자인 원칙 "헐리우드 원칙": 먼저 연락하지 마세요. 저희가 연락을 드리겠습니다.

헐리우드 원칙을 활용하면 고수준 구성요소에서(저수준에 많의 의존하고 있는 구성요소) 저수준 구성요소가 필요할 때만 직접 호출한다. 저수준 구성요소가 컴퓨테이션에 참여할 수 있으면서 저수준 구성요소와 고수준 계층 사이에 의존성을 만들어내지 않도록 한다.

![CaffeineBeverage](https://user-images.githubusercontent.com/48785060/141606427-10c56a52-c9e6-4403-b2bf-9b2134c7bbd0.png)

- CaffeineBerage는 고수준 구성요소다. 메스드 구현이 필요한 상황에서만 서브클래스를 호출한다.
- 서브 클래스는 추상 메서드들을 구현하기 위한 용도로만 쓰이며 호출 당하기 전까지는 추상 클래스를 직접 호출하지 않는다.
- Client에서도 CaffeineBeverage에 추상화 돼 있는 부분에 의존, 그렇게 함으로써 전체 시스템의 의존성이 줄어들 수 있다.

<br>

### 템플릿 메서드 패턴와 스트래티지 패턴

- 템플릿 메서드 패턴

  - 알고리즘의 개요(순서, 구조, 골격)를 정의한다. 실제 작업 중 일부는 서브클래스에서 구현함으로써 알고리즘의 각 단계마다 다른 구현을 사용하면서 알고리즘 구조 자체는 그대로 유지할 수 있다.
  - 상속을 통해 알고리즘을 캡슐화한다. 서브클래스에서 중복되는 코드는 전부 추상클래스에서 가지고 있기 때문에 서브클래스에서 공유할수 있으면서 또한 서브클래스에 일부 행동을 지정해줄 수 있다.

- 스트래티지 패턴
  - 일련의 **알고리즘군**을 정의, 그 알고리즘들을 서로 바꿔가면서 쓸 수 있게 해준다. 각 알고리즘은 캡슐화 돼 있어 클라이언트에서도 손쉽게 서로 다른 알고리즘을 사용할 수 있다.
  - 상속뿐만 아니라 객체 구성을 통해서 알고리즘 구현을 선택할 수 있게 해준다.

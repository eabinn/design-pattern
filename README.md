# Decorator Pattern

## 목적
실행중에 클래스를 꾸밈으로써 원래 클래스의 코드는 전혀 바꾸지 않고도 객체에 새로운 임무를 부여한다.

---

### 상속을 남용하는 전형적인 예
- 커피 전문점이 있다. 이 전문점에서는 Beverage 라는 하나의 추상클래스를 두고 새 메뉴가 생길때마다 이 추상클래스를 구현하게 된다.
- <b>문제점은?</b> 메뉴가 늘어날수록 서브클래스들이 폭팔적으로 증가하게 된다. 코드의 재사용성은 어렵게 되고 관리 또한 어렵게 된다.

### 그럼 공통된 부분을 하나의 공통된 클래스로 뺴고 이 클래스를 상속받아서 추가 사항을 관리하면 안되나?
- 그래도 어떤 메서드에 추가적으로 구현이 생기는 부분이 필요하다면 서브클래스에서 오버라이드 해줘야 한다.
```
class Beverage {
    hasCoffee() {
        return true // coffee에 대해 getter와 setter가 필요하지만 일단 true 반환하도록 구현
    }
    cost() {
        let condimentCost = 0
        if (this.hasCoffee()) {
            condimentCost += 1000
        }
        return condimentCost
    }
}

class Latte extends Beverage {
    cost() {
        return 1000 + super.cost()
    }
}
```
- 일부 서브클래스에 적합하지 않은 기능을 베이스 클래스에 추가하게되는 문제가 생긴다.

### 구성과 위임을 통해서 실행중에 행동을 '상속' 시켜보자
- 서브클래스를 만드는 과정으로 행동을 상속 받으면 컴파일시에 그 행동은 완전히 결정된다. 그리고 모든 서브클래스에서도 똑같은 행동을 상속받아야 한다.<br>
  -> 하지만 구성을 통해서 객체의 행동을 확장하면 실행중에 동적으로 행동을 설정할 수 있다.
- 객체를 동적으로 구성하면, 기존 코드를 고치는 대신 새로운 코드를 만들어서 새로운 기능을 추가할 수 있다. (OCP)

### OCP (Open-Closed Principle)
- 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.

### 데코레이터 패턴
- 객체를 어떻게 장식하면 될까? 그리고 이 과정에서 어떤 식으로 위임을 할 수 있을까?

### 데코레이터를 써서 음료 주문을 완성해보자. (ex. 모카와 휘핑크림을 추가한 다크 로스트 커피 주문)
1. DarkRoast 객체를 만들자. DarkRoast는 Beverage로부터 상속을 받는다.
2. Mocha도 주문했으니 Mocah 객체를 만들고 그 객체로 DarkRoast 객체를 감싼다.
    - Mocha 객체는 데코레이터다. 이 객체의 형식(타입)은 이 객체가 장식하고 있는 객체를 반영하므로 Beverage가 된다.
    - Mocha가 감싸고 있는 것도 Beverage 객체로 간주할 수 있다.
3. Whip 데코레이터를 만들고 그 객체로 Mocha 객체를 감싸자.
4. 가격을 구하기 위해서는 가장 바깥쪽 데코레이터는 Whip의 cost()를 호출하면된다.
    - 그러면 Whip에서는 그 객체가 장식하고 있는 객체에게 가격 계산을 위임한다. 그리고 위임하고 리턴 받으면서 가격을 구하게 된다.

### 중간 정리
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
    - 따라서 감싸고 있는 객체가 할 수 있는 것들을 데코레이터도 할 수 있다.
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 것 외에도 원하는 추가적인 작업을 수행할 수 있다.
- 객체는 언제든지 감쌀 수 있기 때문에 실행중에 필요한 데코레이터를 마음대로 적용할 수 있다.

### 데코레이터 패턴의 정의
- 데코레이터 패턴에서는 객체에 추가적인 요건을 동적으로 첨가한다.
- 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.

### 데코레이터 패턴을 적용한 Beverage 객체 다이어그램
![ctCkm](https://user-images.githubusercontent.com/48785060/139590453-23293136-2a20-4cf1-be26-3a818935c9f4.png)
- Bevearge는 직접 쓰일 수도 있고 데코레이터로 감싸져서 쓰일 수도 있다.
- ConcreteComponent인 HouseBlend, Decaf 등에는 새로운 행동을 동적으로 추가할 수 있다.
- 각 데코레이터 안에는 Beverage 객체가 들어있다. ConcreteDecorator인 Milk, Mocha 등에는 구성요소(Beverage)에 대한 레퍼런스가 들어있는 인스턴스 변수가 있다.
- Decorator은 Component의 상태를 확장할 수 있으며 새로운 메서드도 추가할 수 있다. 하지만 일반적으로 새로운 메서드를 추가하기 보다는 Component에 원래 있던 메서드를 호출하기 전 또는 후에 별도의 작업을 처리하는 방식으로 새로운 기능을 추가한다.

### 데코레이터 패턴에서는 상속 대신 구성을 사용하는 것이 아니었나?
- 데코레이터의 형식이 데코레이터로 감싸는 객체의 형식을 맞추기 위해 상속을 사용한다.
- 행동을 받기 위해 상속을 사용하는 것이 아니고 단지 형식을 맞추기 위해 상속을 사용한다. 대체하는 것과 동일한 형식이여야지 그 자리를 대체할 수 있다.
- 어떤 구성요소를 가지고(데코레이터에는 구성요소에 대한 레퍼런스가 있는 인스턴스 변수가 있다) 데코레이터를 만들때 새로운 행동을 추가하게 된다.

### 질문
- 특정 구상 구성요소(예를 들면 시즈널 한정 판매 커피)인지 확인한 다음 어떤 작업을 처리하는 경우 데코레이터 패턴을 적용하기 어렵지 않나?
    - 맞다. 추상 구성요소 형식을 바탕으로 돌아가는 코드에 대해서 데코레이터 패턴을 적용해야만 제대로 된 결과를 얻을 수 있다.

### 데코레이터 패턴을 사용할 때 주의할 점
- 특정 형식에 의존하는 클라이언트 코드에 대해서 생각없이 데코레이터 패턴을 적용하는 경우 데코레이터를 사용해도 클라이언트에서는 데코레이터가 적용됐는지 모르는 경우가 생길 수 있다. 
- 데코레이터를 도입하면 구성요소를 초기화하는데 필요한 코드가 훨씬 복잡해질 수 있다. 어떤 구성요소를 정의하기 위해 꽤 많은 데코레이터로 감싸야 할수도 있다.

### 데코레이터 패턴 핵심정리
- 상속 대신 데코레이터 패턴을 통해 기존 코드를 수정하지 않고도 행동을 확장할 수 있다.
- 데코레이터 패턴에서는 구상 구성요소(추상 구성요소를 구현한 요소)를 감싸주는 데코레이터를 사용한다.
- 데코레이터 클래스의 형식은 그 클래스가 감싸고 있는 클래스의 형식을 반영한다. (상속 또는 인터페이스 구현을 통해 자신이 감쌀 클래스와 같은 형식을 가지게 된다.)
- 데코레이터에서는 자기가 감싸고 있는 구성요소의 메서드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장한다.
- 구성요소의 클라이언트 입장에서는(실행중에 구성요소를 사용하는 곳) 데코레이터의 존재를 알 수 없다.








